# Generated by Django 2.1.7 on 2020-03-11 20:42
import os.path
import logging

import backend.storage
from django.core.files.storage import default_storage
from django.db import migrations, models


def move_attachments_storage(apps, schema_editor):
    log = logging.getLogger()
    # Go through all attachements, and copy them to Swift if they are not already there.
    # Leave existing files on file system.
    DocumentAttachment = apps.get_model('backend', 'DocumentAttachment')
    # TODO: this will always configure the current attachment_store -> may need a historical version here

    old_storage = default_storage
    new_storage = backend.storage.attachment_store

    for da in DocumentAttachment.objects.all():
        # make sure our new filename includes the document uuid
        old_filename = da.file.name
        if not da.file.name.startswith(str(da.document.uuid) + '/'):
            new_filename = os.path.join(str(da.document.uuid), da.file.name)
        else:
            new_filename = da.file.name
        if new_storage.exists(new_filename):
            # file exists in new storage -> nothing to do
            log.info("Ignore existing file %s", new_filename)
            # check if file.name is correct
            if da.file.name != new_filename:
                da.file.name = new_filename
                da.save()
            continue
        if not old_storage.exists(old_filename):
            raise Exception("Not sure what to do ... file ", da.file.name, " does not exist anywhere.")
        # still here, we are ready to move the file
        log.info('Move file %s to %s', old_filename, new_filename)
        f = old_storage.open(old_filename)
        new_storage.save(new_filename, f)
        f.close()
        # update file object with new path 
        da.file.name = new_filename
        da.save()
        log.info('Move done')
        # delete old file
        old_storage.delete(old_filename)
        log.info('Remvoed old file %s', old_filename)


def update_draftmetadata_attachments(apps, schema_editor):
    # We can't import the DraftMetadata model directly as it may be a newer
    # version than this migration expects. We use the historical version.
    DraftMetadata = apps.get_model('backend', 'DraftMetadata')
    for dm in DraftMetadata.objects.all():
        for att in dm.data['attachments']:
            # an attachement has attributes 'delete_url', 'file', 'name'
            # ... 'name' was the da.file.name -> change to da.name
            # ... 'file' was a /media/ url (da.file.url) -> change to DownloadAttachment url
            # convert 'file' url to new name
            if not att['file'].startswith('/media/'):
                # ignore it ... not a local file anymore
                continue
            new_file_name = os.path.join(str(dm.document.uuid), os.path.basename(att['file']))
            # find attachement for this file and update 'name' and 'file' attribute in attachement
            for attachment in dm.document.attachments.all():
                if attachment.file.name == new_file_name:
                    # set name
                    att['name'] = attachment.name
                    # set curl from store
                    att['file'] = attachment.file.url
        dm.save()

class Migration(migrations.Migration):

    dependencies = [
        ('backend', '0009_auto_20200228_0116'),
    ]

    operations = [
        migrations.RunPython(move_attachments_storage),
        migrations.AlterField(
            model_name='documentattachment',
            name='file',
            field=models.FileField(storage=backend.storage.AttachmentStorage(), upload_to=backend.storage.document_upload_path),
        ),
        migrations.RunPython(update_draftmetadata_attachments)
    ]
